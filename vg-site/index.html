<!DOCTYPE html>
<html>
<head>
  <title>Geo + Embeddings</title>
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAacf5_dHXHI8AYrfjbOgpZrOIHMQ3zHz0&callback=Function.prototype"></script>
  <script src="https://unpkg.com/h3-js"></script>
  <!-- Add Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <style>
    /* Container styles */
    #map {
      height: 100vh;
      width: 100vw;
      position: relative;  /* Added this */
    }
    .gm-undo {
      display: none !important;
    }
    /* Slider styles */
    #slider-container {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background-color: rgba(210, 180, 140, 0.7);  /* Added this */
      padding: 10px;  /* Added this */
      border-radius: 12px;  /* Added this */
      border-color: black;  /* Added this */
      border-width: 1px;  /* Added this */
      border-style: solid;  /* Added this */
      text-align: center;  /* Added this */
    }

    /* Spinner styles */
    .spinner {
      border: 5px solid rgba(0, 0, 0, 0.2);
      border-radius: 50%;
      border-top: 5px solid #000000;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      position: absolute;
      z-index: 1001;
      display: none;
      bottom: 10px;  /* Added this */
      left: 10px;  /* Added this */
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Global Styles */
    body, h1, h2, p, ul, li {
      font-family: 'Roboto', sans-serif;
    }

    /* Splash Screen styles */
    #splash-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);  /* Darker background */
      z-index: 2000;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #splash-content {
      background: linear-gradient(135deg, rgba(0, 157, 255, 0.9), rgba(0, 217, 255, 0.9));  /* Gradient background */
      padding: 30px;
      border-radius: 20px;  /* More rounded edges */
      box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);  /* Box shadow */
      width: 40%;
      height: auto;  /* Auto height */
      text-align: left;
      color: white;  /* White text */
    }

    h1, h2 {
      margin-top: 0;
    }

    button {
      background-color: white;
      color: blue;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    button:hover {
      background-color: lightgray;
    }
  </style>
</head>
<body>

  <!-- Splash Screen -->
  <div id="splash-screen">
    <div id="splash-content">
      <h1>Welcome to VectorGeo!</h1>
      <p>This site uses a deep embedding model to build a vector space representation of the world.</p>
      <h2>How to Use</h2>
      <ul>
        <li>Move the circle around to query different areas. The circle's center is the query point.</li>
        <li>Shrink or expand the circle for a smaller or bigger search area. Only sites within the circle will be included in the search</li>
        <li>Adjust the coverage fraction slider to tweak the sensitivity.</li>
      </ul>
      <div style="text-align: center;">
        <img src="vg-user-animation-fast.gif" alt="User Guide Animation">
      </div>
      <div style="text-align: center;"> <!-- Center align container -->
        <button onclick="closeSplash()" style="font-size: 24px;">Got it!</button>

      </div>
    </div>
  </div>

  <div id="map"></div>
  <div id="slider-container">
    <label for="coverage">Coverage Fraction: </label>
    <input type="range" id="coverage" name="coverage" min="0.1" max="1" step="0.05" value="0.1">
    <span id="coverage-value">0.3</span>
  </div>
  <div id="spinner" class="spinner"></div>


  <script>
    let map;
    let circle;
    let markers = [];
    let coverageFraction = 0.2;

    // Update coverage fraction when the slider changes
    document.getElementById('coverage').addEventListener('input', function() {
      coverageFraction = parseFloat(this.value);
      document.getElementById('coverage-value').textContent = coverageFraction;
      updateCircleRadius();  // Update the markers based on the new coverage fraction
    });

    // Declare dict mapping h3 resolution to square meters per cell
    const h3_resolution = 7
    const h3ResolutionToArea = {
      0: 4357449.416078381,
      1: 609788.441794133,
      2: 86801.780398997,
      3: 12393.434655088,
      4: 1770.347654491,
      5: 252.903858182,
      6: 36.129062164,
      7: 5.161293360,
      8: 0.737327598,
      9: 0.105332513,
      10: 0.015047502,
      11: 0.002149643,
      12: 0.000307092,
      13: 0.000043870,
      14: 0.000006267,
      15: 0.000000895
    };

    area_per_h3_m2 = h3ResolutionToArea[h3_resolution] * 1000 * 1000;

    function debounce(func, wait) {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }
    
  
    function initMap() {
      const center = { lat: 47.586301, lng: -122.377568 };
      map = new google.maps.Map(document.getElementById("map"), {
        center: center,
        zoom: 10,
        mapTypeId: 'terrain'
      });

      circle = new google.maps.Circle({
        center: center,
        radius: 10000,
        editable: true,
        draggable: true,
        map: map,
        fillOpacity: 0.2,
      });

      google.maps.event.addListener(circle, 'radius_changed', updateCircleRadius);
      google.maps.event.addListener(circle, 'center_changed', updateCircleCenter);
    }

    function showSpinner() {
      const spinner = document.getElementById('spinner');
      spinner.style.display = 'block';
    }

    function hideSpinner() {
      const spinner = document.getElementById('spinner');
      spinner.style.display = 'none';
    }

    const debouncedFetchLocations = debounce(fetchLocations, 500);

    async function fetchLocations(lat, lng, radius, render_mode='hexagon') {
      const h3_hex = h3.latLngToCell(lat, lng, h3_resolution);
      const AWS_LAMBDA_URL = "https://odme3rsnq2.execute-api.us-east-1.amazonaws.com/default";
      
      // The limit should be the number of hexagons required to cover 10% of the circle area
      var radius = circle.getRadius();
      const limit = Math.ceil((radius * radius * Math.PI) / area_per_h3_m2 * coverageFraction);

      showSpinner();
      const req_body = JSON.stringify({ lat: lat, lon: lng, h3: h3_hex, circleRadiusMeters: radius, limit: limit });

      const response = await fetch(AWS_LAMBDA_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: req_body
      });

      const data = await response.json();
      const locations = data.locations;
      const scores = data.scores;

      // if scores or locations is zero length / empty, print a message
      if (scores.length === 0 || locations.length === 0) {
        console.log(`No locations found for lat: ${lat}, lng: ${lng}, radius: ${radius}`);
        hideSpinner();
        return;
      }

      // Normalize scores
      const maxScore = Math.max(...scores);
      const minScore = Math.min(...scores);

      // Clear old markers
      markers.forEach(marker => marker.setMap(null));
      markers = [];

      // Add new markers
      locations.forEach((location, index) => {
        const normalizedScore = (scores[index] - minScore) / (maxScore - minScore);
        const color = `rgba(0, 0, 255, ${normalizedScore})`; // Red with varying opacity based on score
        let marker;
        if (render_mode === 'hexagon') {
          // Everything here uses lat-lng ordering, not lng-lat
          const h3_cell = h3.latLngToCell(location.lat, location.lon, h3_resolution);

          // Disable geojson ordering
          const hexagon = h3.cellToBoundary(h3_cell, false);
          const hexagon_latlngs = hexagon.map(coord => {
            const latLng = new google.maps.LatLng(coord[0], coord[1]);
            return new google.maps.LatLng(latLng.lat(), latLng.lng());
          });
          
          marker = new google.maps.Polygon({
            paths: hexagon_latlngs,
            strokeColor: color,
            strokeOpacity: 0.8,
            strokeWeight: 2,
            fillColor: color,
            fillOpacity: 0.35,
            map: map
          });
        }
        else if (render_mode === 'circle') {
          marker = new google.maps.Marker({
            position: { lat: location.lat, lng: location.lon },
            map: map,
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              fillColor: color,
              fillOpacity: 0.6,
              strokeWeight: 0,
              scale: 5,
              strokeColor: '#000000',  // Black color for the edge
              strokeWeight: 2,  // Thickness of the edge
            }
          });
        }
        else {
          console.log('Invalid render mode, select one of "hexagons" or "circle"');
          }
        markers.push(marker);
        }
      );
      hideSpinner();
    }


    function updateCircleRadius() {
      const radius = circle.getRadius();
      const center = circle.getCenter();
      debouncedFetchLocations(center.lat(), center.lng(), radius);
    }

    function updateCircleCenter() {
      const radius = circle.getRadius();
      const center = circle.getCenter();
      debouncedFetchLocations(center.lat(), center.lng(), radius);
    }

    // Initialize the map
    initMap();

    // Add idle event listener to fetch locations once the map is fully loaded
    google.maps.event.addListenerOnce(map, 'idle', function() {
      fetchLocations(circle.getCenter().lat(), circle.getCenter().lng(), circle.getRadius());
    });

    function closeSplash() {
      document.getElementById('splash-screen').style.display = 'none';
    }


  </script>
</body>
</html>